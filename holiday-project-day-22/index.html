<!DOCTYPE html>
<head prefix='og: http://ogp.me/ns#'>
  <meta charset='utf-8'>
  <meta content='IE=edge' http-equiv='X-UA-Compatible'>
  <meta content='width=device-width, initial-scale=1.0' name='viewport'>
  <meta content='프로젝트 22일: Promise와 Async.js로 작성해본 콜백 코드 비교' property='og:title'>
  <meta content='website' property='og:type'>
  <meta content='http://hatemogi.com/holiday-project-day-22/' property='og:url'>
  <meta content='자바스크립트 자체만으로도 그렇지만, 특히 Node.js 환경은 비동기 I/O가 중요해서, 콜백 방식의 함수 호출이 자주 활용되며, 그 호출간의 중첩도 잦다. 즉, 콜백에서 다시 콜백 걸고 또 콜백 거는, 계속 중첩되는 콜백이 필요한 경우가 많다. 이 연속되는 콜백을 그냥 평범하게 코딩하면, 마치 예외처리 (try-catch-finally) 구문 없이 코딩하는 것처럼, 예외 처리에 대한 코드가 중간중간 끼어들어서 정상적인 로직 코드가 묻혀버리기 쉽다. Promise와 Async.js로 이 문제를 해결해보자.' property='og:description'>
  <title>프로젝트 22일: Promise와 Async.js로 작성해본 콜백 코드 비교</title>
  <link href='/css/application.css' rel='stylesheet' type='text/css'>
  <link href='/css/highlight/foundation.css' rel='stylesheet' type='text/css'>
  <link href='/img/favicon.png' rel='shortcut icon'>
</head>
<body>
  <div class='container'>
    <div class='header'>
      <ul class='nav nav-pills pull-right'>
        <li>
          <a href='/'>홈</a>
        </li>
        <li>
          <a href='/articles/'>글</a>
        </li>
        <li>
          <a href='/show-your-work/'>작업</a>
        </li>
        <li>
          <a href='/about/'>소개</a>
        </li>
      </ul>
      <h3 class='logo'>hatemogi</h3>
    </div>
  </div>
  <section id='main-content'>
    <div class='container'>
      <div class='page-header'>
        <h1>
          프로젝트 22일: Promise와 Async.js로 작성해본 콜백 코드 비교
          <small>2014-05-31</small>
        </h1>
      </div>
      <p>오늘은 프로젝트 22일째 작성한 Async.js 코드와 Promise 코드를 비교해본다.</p>
      
      <h2>콜백 중첩의 늪</h2>
      
      <p>자바스크립트 자체만으로도 그렇지만, 특히 Node.js 환경은 비동기 I/O가 중요해서, 콜백 방식의 함수 호출이 자주 활용되며, 그 호출 간의 중첩도 잦다. 즉, 콜백에서 다시 콜백 걸고 또 콜백 거는, 계속 타고들어가는 콜백이 필요한 경우가 많다.</p>
      
      <p>이 연속되는 콜백을 그냥 평범하게 코딩하면, 마치 예외처리 (try-catch-finally) 구문 없이 코딩하는 것처럼, 예외 처리에 대한 코드가 중간중간 끼어들어서 정상적인 로직 코드가 묻혀버리기 쉽다.</p>
      
      <p><a href="/holiday-project-day-10/">10일째 작성했던 코드를 다시 예로 들어보자.</a></p>
      
      <pre><code class="js">nodegit = require("nodegit")&#x000A;&#x000A;describe '[CoffeeScript] nodegit 저장소', () -&gt;&#x000A;  it '열어서 커밋 찾아보기', (done) -&gt;&#x000A;    sha = "e9ec116a8fb2ea051a4c2d46cba637b3fba30575"&#x000A;    nodegit.Repo.open "git/nodegit", (err, repo) -&gt;&#x000A;      return done(err) if err&#x000A;      expect(repo.path()).toMatch /\.git\/$/&#x000A;      repo.getCommit sha, (err, entry) -&gt;&#x000A;        return done(err) if err&#x000A;        expect(entry.sha()).toEqual sha    &#x000A;        done()&#x000A;</code></pre>
      
      <p>보통의 비동기 콜백 함수들이 파라미터로 <code>(err, result)</code>를 받는 형태이고, 처리 과정에서 에러가 발생하면 err에 에러 관련 값이 들어오고, 정상처리됐으면 null이 온다. 그리고, result에 결과값이 담겨있는 형태다.</p>
      
      <p>위 코드의 중간마다 있는 <code>return done(err) if err</code> 부분이 에러 상황에 Jasmine 프레임워크에 에러 결과를 리포팅하겠다는 코드인데, 콜백 도입부마다 똑같은 코드를 넣어서 전체 코드가 눈에 잘 띄지 않게 됐다.</p>
      
      <h2>Promise와 Async.js</h2>
      
      <p>이 불편함을 해결하는 방법이 여럿 있을 것 같은데, 그중에서도 Async.js와 Promise를 살펴봤다. Async.js는 비동기 호출에 편리한 유틸리티 함수들이 제공되는 라이브러리여서, npm등으로 잘 가져다가 사용하면 된다. 평범한 자바스크립트 라이브러리라 브라우저에서 사용해도 된다. 한편, Promise는 사실 자바스크립트(ECMAScript) 스펙에 포함되는 규약인데, 아직 지원하지 않는 자바스크립트 엔진을 위해, 별도 구현체 중에 하나 가져다가 쓰면 된다.</p>
      
      <p>콜백 방식의 호출은 물론, Promise와 Async.js도 익숙치 않기 때문에, 연습해볼 겸 똑같은 코드를 둘다의 방식으로 작성해봤다. nodegit으로 git 저장소를 열고, 커밋 두 개에 엮인 트리를 찾아서 둘 사이 차이(패치 크기)를 알아보는 메소드를 작성했고, 코드는 아래와 같다.</p>
      
      <h3><a href="https://github.com/hatemogi/holiday-project/blob/day-22/spec/nodegit/repo_async_spec.coffee">Async로 작성한 코드</a></h3>
      
      <pre><code class="js">nodegit = require("nodegit")&#x000A;async = require("async")&#x000A;_ = require("underscore")&#x000A;&#x000A;nodegitPath = ".git/modules/git/nodegit/"&#x000A;&#x000A;describe '[CoffeeScript w/async.js] nodegit 저장소', () -&gt;&#x000A;  it '열어서 커밋 찾아보기', (done) -&gt;&#x000A;    sha = "e9ec116a8fb2ea051a4c2d46cba637b3fba30575"&#x000A;    open = nodegit.Repo.open&#x000A;    async.waterfall [&#x000A;      open.bind(open, nodegitPath)&#x000A;      (repo, cb) -&gt;&#x000A;        expect(repo.path()).toMatch /\/git\/nodegit\/$/&#x000A;        repo.getCommit sha, cb&#x000A;      (entry, cb) -&gt;&#x000A;        expect(entry.sha()).toEqual sha&#x000A;        cb null&#x000A;    ], done&#x000A;&#x000A;  it 'diff 실행해보기', (done) -&gt;&#x000A;    async.waterfall [&#x000A;      (cb) -&gt;&#x000A;        nodegit.Repo.open nodegitPath, cb&#x000A;      (repo, cb) -&gt;&#x000A;        async.parallel [&#x000A;          repo.getCommit.bind(repo, "33c7b930acc13148ef6f05df56f9b8a5c3578a57"),&#x000A;          repo.getCommit.bind(repo, "c3e4be4448d2a99917431d3be972ca262805f989")&#x000A;        ], (err, commits) -&gt; cb(err, repo, commits)&#x000A;      (repo, commits, cb) -&gt;&#x000A;        async.parallel [&#x000A;          repo.getTree.bind(repo, commits[0].treeId()),&#x000A;          repo.getTree.bind(repo, commits[1].treeId())&#x000A;        ], cb&#x000A;      (trees, cb) -&gt;&#x000A;        trees[0].diff trees[1], cb&#x000A;      (diff, cb) -&gt;&#x000A;        expect(_.reduce(diff.patches(), ((m, p) -&gt; m + p.size()), 0)).toBe(2)&#x000A;        cb null&#x000A;    ], done&#x000A;</code></pre>
      
      <p><code>async.waterfall</code>과 <code>async.parallel</code> 함수를 사용해서 작성했고, 전체적 흐름은 일관되고 편리하다. 하지만, 콜백 꼬리 <code>cb</code>를 늘 달고 다녀야 하는 아쉬움(?)이 있다.</p>
      
      <h3><a href="https://github.com/hatemogi/holiday-project/blob/day-22/spec/nodegit/repo_promise_spec.coffee">Promise로 작성한 코드</a></h3>
      
      <pre><code class="js">nodegit = require("nodegit")&#x000A;Promise = require("promise")&#x000A;_ = require("underscore")&#x000A;&#x000A;nodegitPath = ".git/modules/git/nodegit/"&#x000A;&#x000A;openRepo = Promise.denodeify(nodegit.Repo.open)&#x000A;getCommit = (repo) -&gt;&#x000A;  Promise.denodeify(repo.getCommit.bind(repo))&#x000A;getTree = (repo) -&gt;&#x000A;  Promise.denodeify(repo.getTree.bind(repo))&#x000A;getDiff = (tree) -&gt;&#x000A;  Promise.denodeify(tree.diff.bind(tree))&#x000A;&#x000A;describe '[CoffeeScript w/promise.js] nodegit 저장소', () -&gt;&#x000A;  it '열어서 커밋 찾아보기', (done) -&gt;&#x000A;    sha = "e9ec116a8fb2ea051a4c2d46cba637b3fba30575"&#x000A;    openRepo(nodegitPath).then((repo) -&gt;&#x000A;      expect(repo.path()).toMatch /\/git\/nodegit\/$/&#x000A;      getCommit(repo)(sha)&#x000A;    ).then((entry) -&gt;&#x000A;      expect(entry.sha()).toEqual sha&#x000A;    ).then done, done&#x000A;&#x000A;  it 'diff 실행해보기', (done) -&gt;&#x000A;    openRepo(nodegitPath).then((repo) -&gt;&#x000A;      Promise.all([&#x000A;        getCommit(repo)("33c7b930acc13148ef6f05df56f9b8a5c3578a57"),&#x000A;        getCommit(repo)("c3e4be4448d2a99917431d3be972ca262805f989")&#x000A;      ]).then((c) -&gt;&#x000A;        Promise.all [&#x000A;          getTree(repo)(c[0].treeId()),&#x000A;          getTree(repo)(c[1].treeId())&#x000A;        ]&#x000A;      )&#x000A;    ).then((trees) -&gt;&#x000A;      getDiff(trees[0])(trees[1])&#x000A;    ).then((diff) -&gt;&#x000A;      patchsize = _.reduce(diff.patches(), ((m, p) -&gt; m + p.size()), 0)&#x000A;      expect(patchsize).toBe(2)&#x000A;    ).then done, done&#x000A;</code></pre>
      
      <p>Promise의 경우, 전체 메시지를 마치 보통 동기 호출 스타일로 작성하자는 것이 포인트인데, 어떤 비동기 처리 뒤에 <code>then</code> 함수를 붙여서, 성공한 경우와 실패한 경우의 처리를 한다. 계속 연결해서 (chaining) 사용하는 것이 핵심이라면 핵심이다.</p>
      
      <p>위 코드는 <code>Promise.then</code>과 <code>Promise.all</code>을 사용했다. 결국 두 코드 스타일이 비슷해졌다. 팀 동료들에게 물어보니, Async가 더 보기 좋다는 사람도 있던데, 내 경우에는 Promise가 좋게 느껴지는 면도 있다고 생각한다. 우선 늘 쫓아다녀야 하는 콜백 함수 꼬리표를 떼놓고 생각할 수 있고, 코드의 흐름이 차례로 흐르는 방식이 평소 동기화 방식 코딩을 할 때와 크게 다르지 않아서 좋다.</p>
      
      <h2>그러나, 둘 중 하나를 쓴다면&hellip;</h2>
      
      <p>Async.js의 경우, 비동기 호출과 관련한 다양한 유틸리티가 많아서, 1:1로의 비교는 어렵지만, waterfall에 한정 지어 비교해본다면 결론이 쉽게 난다.</p>
      
      <p>Promise 스타일이 내게는 더 좋지만, 문제는, 이미 널리 있는 자바스크립트 라이브러리들이나 Node.js의 기본 API들이 일반 콜백 방식으로만 되어있지, Promise 스타일로 준비된 것이 아니어서, 위 코드에서처럼 <code>Promise.denodeify</code>같은 유틸리티 함수로 Promise화 한다거나, 아니면 직접 Promise 함수로 만들어 놔야 한다는 단점이 있다.</p>
      
      <p>한마디로, 이미 통용되는 코드를 그대로 활용하기에는 Async.js가 좋은 것 같다. Promise 스타일이 더 널리 쓰이기 시작해서 다른 API들도 그 스타일대로 쓸 수 있게 되면 적극적으로 활용해보기 좋다고 생각한다. 그전까지는 Async.js의 활용도가 더 높을 수밖에 없을 것 같다.</p>
      
      <h2>한편, 콜백의 불편함을 감수해야 하나?</h2>
      
      <p>한편, 조금 원론적인 얘기로, 비동기 코딩으로 왜 콜백의 불편함을 감수해야 할까? 자바스크립트 코딩할 때나, Node.js 코딩에서도 마찬가지로 그냥 동기화 방식으로 코딩하면 안 될까? 물론 된다. 하지만, 동기화 함수를 만날 때마다 블럭킹이 일어나면, 다른 코드가 동시에 실행될 수 없으므로, 클라이언트 코드의 경우 화면 응답성 등이 떨어질 것이고, 서버 코드의 경우 동시에 여러 사용자 처리를 할 수 없을 것이다.</p>
      
      <p>즉, 한마디로 동시성(concurrency) 확보를 위해 비동기 I/O 호출을 하게 되는 것인데, 사실 따지고 보면 기존에 JAVA 등으로 멀티쓰레딩 처리를 했던 것도 마찬가지로 동시성 확보를 위해 하는 일인데, 그 멀티 쓰레드 처리를 잘하기 위해 임계영역(critical section)을  잘 관리해야 하며, 신경 써야 할 점도 많다.</p>
      
      <p>어찌 보면 멀티쓰레드로 개발하는 것이, 당장엔 편해 보이지만 자칫하면 동시 사용자가 몰렸을 때 제대로 처리되지 않아 쓰레드 안정성(thread-safty)이 깨진 경우의 문제가 발생한다거나 하는 심각한 문제로의 발전 가능성이 있다. 그런 면에서는 콜백 처리의 불편함쯤이야 한번 감수하면 뒤탈은 적은 방식일지도 모른다.</p>
      
      <p>이상으로, Promise와 Async.js로 <strong>콜백 중첩 문제</strong>를 해결해보았다.</p>
      
      <p>오늘은 여기까지.</p>
      <div class='page-header'>
        <h4>
          30일 프로젝트 글 목록
        </h4>
      </div>
      <blockquote>
        <ul>
        <li><a href="/holiday-project-day-01/">(05/07) 프로젝트 1일: 웹 브라우저 JS 테스트 환경 - karma &amp; jasmine</a></li>
        <li><a href="/holiday-project-day-02/">(05/08) 프로젝트 2일: 서버 측 JS 테스트 환경 - jasmine-node</a></li>
        <li><a href="/holiday-project-day-03/">(05/09) 프로젝트 3일: express 테스트 환경 - supertest</a></li>
        <li><a href="/holiday-project-day-04/">(05/10) 프로젝트 4일: 웹 환경 패키지 매니저 - bower</a></li>
        <li><a href="/holiday-project-day-05/">(05/11) 프로젝트 5일: 문법 하이라이팅 - highlight.js</a></li>
        <li><a href="/holiday-project-day-06/">(05/12) 프로젝트 6일: 그래프 그리기 - graphviz &amp; D3.js</a></li>
        <li><a href="/holiday-project-day-07/">(05/13) 프로젝트 7일: graphviz 노드에 웹 링크 걸기</a></li>
        <li><a href="/holiday-project-day-08/">(05/14) 프로젝트 8일: D3.js 트랜지션(Transitions)</a></li>
        <li><a href="/holiday-project-day-09/">(05/15) 프로젝트 9일: Node.js로 Git저장소 다루기</a></li>
        <li><a href="/holiday-project-day-10/">(05/16) 프로젝트 10일: Async.js로 콜백 중첩을 풀기</a></li>
        <li><a href="/holiday-project-day-11/">(05/17) 프로젝트 11일: Git 커밋 그래프 그리기 도전</a></li>
        <li><a href="/holiday-project-day-12/">(05/18) 프로젝트 12일: 그래프 그리기 도전 #2</a></li>
        <li><a href="/holiday-project-day-13/">(05/19) 프로젝트 13일: 컨테이너 기반 가상화 프레임워크 - Docker</a></li>
        <li><a href="/holiday-project-day-14/">(05/20) 프로젝트 14일: Heroku에 Node.js 애플리케이션 배포</a></li>
        <li><a href="/holiday-project-day-15/">(05/21) 프로젝트 15일: AngularJS 코드스쿨 강좌 소개</a></li>
        <li><a href="/holiday-project-day-16/">(05/22) 프로젝트 16일: 중간 점검 - 왜 이 프로젝트를 하나?</a></li>
        <li><a href="/holiday-project-day-17/">(05/23) 프로젝트 17일: Travis CI - 지속적 통합 서비스</a></li>
        <li><a href="/holiday-project-day-18/">(05/24) 프로젝트 18일: Grunt - 자바스크립트 작업 실행기</a></li>
        <li><a href="/holiday-project-day-19/">(05/25) 프로젝트 19일: RequireJS - 비동기(async) JS 로더'</a></li>
        <li><a href="/holiday-project-day-20/">(05/26) 프로젝트 20일: 회사의 합병 소식</a></li>
        <li><a href="/holiday-project-day-21/">(05/29) 프로젝트 21일: AngularJS 컨트롤러 테스트 코드</a></li>
        <li><a href="/holiday-project-day-22/">(05/31) 프로젝트 22일: Promise와 Async.js로 작성해본 콜백 코드 비교</a></li>
        </ul>
      </blockquote>
    </div>
  </section>
  <div class='container'>
    <footer>
      <div class='pull-right'>
        &copy; 2012-2014
        <a href='https://twitter.com/hatemogi'>@hatemogi</a>
      </div>
    </footer>
  </div>
  <script src='/js/application.js' type='text/javascript'></script>
</body>
